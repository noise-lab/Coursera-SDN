<span class="c11">In this exercise, you will be working with the</span> <span>Kinetic</span><span class="c11"> controller</span><span>, which</span><span class="c11"> permits event-driven network control.</span>

<span></span>

<span>Kinetic</span><span class="c11"> is an SDN control</span><span> module</span><span class="c11"> that can dynamically react to various types of network events (e.g., intrusion detection, bandwidth limit reached, etc.) by changing the applied network policy dynamically. Event-driven SDN control makes networks easier to manage by automating many tasks that are currently performed by manually modifying multiple distributed device configuration files, which are expressed in low-level, vendor-specific CLI commands. </span>

<span></span>

<span>Kinetic</span><span class="c11"> augments the original Pyretic code base with many useful features to present an attractive and engaging environment for implementing an event-driven SDN controller. Moreover, Pyretic's modular programming model allows programmers to build a complex network policy by composing multiple network policies together (sequential or parallel). Unlike previous weeks, this week you will be taken through the steps of writing reactive network applications using</span> <span>Kinetic—</span><span class="c11">giving operators access to dynamically changing network policies</span><span>—</span><span class="c11">and testing them using Mininet. The purpose of this exercise is to show you yet another way of writing dynamic network applications.</span>

<span></span>

<span>Another benefit to Kinetic is that its dynamic behavior is verifiable.  A network operator can write dynamic network policies in terms of a Finite State Machine (FSM), and these policies are automatically translated into a form that a model checker can verify for certain properties.  For example, it is possible to verify certain properties such as “when an intrusion detection system indicates that a host is infected, the host will always be blocked from the network”</span>

<span class="c11"></span>

<span class="c11">After the walkthrough, you will be asked to implement a simple server load-balancing application on</span> <span>Kinetic</span><span class="c11"> and test it using</span> <span>M</span><span class="c11">ininet. More details on creating and submitting the code will be provided later on in the instructions. So, as always, make sure that you follow each step carefully.</span>

<span class="c11"></span>

## <a name="h.gjdgxs"></a><span class="c13 c2 c3">Walkthrough</span>

<span class="c11">The network you'll use in this exercise includes</span> <span>three</span><span class="c11"> hosts and a switch</span><span>.</span><span class="c11"> </span><span>In this exercise</span><span class="c11">, you will use the</span> <span>Kinetic</span><span class="c11"> </span><span>controller</span><span class="c11"> to</span> <span>implement</span><span class="c11"> your network applications.</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 488.90px; height: 340.50px;">![](https://d396qusza40orc.cloudfront.net/sdn/srcs/Kinetic%20Assignment/image02.png)</span>

<span class="c11 c3">Figure 1: Topology for the Network under Test</span>

<span class="c11 c3"></span>

## <a name="h.30j0zll"></a><span class="c2 c3 c13">What is</span> <span class="c2">Kinetic</span><span class="c13 c2 c3">?</span>

<span class="c20 c4"></span>

<span class="c3 c27">Kinetic</span><span class="c11"> is an SDN</span> <span>control</span><span class="c11"> framework where operators define a network policy as a Finite State Machine (FSM). Transitions between states are triggered by</span> <span>different</span><span class="c11"> types of dynamic events in the network, (e.g., intrusion detection, authentication of hosts, data usage cap reached, etc.) Based on different network events, operators can enforce different policies to the network using an intuitive FSM model.</span><span> </span><span class="c3 c27">Kinetic</span><span class="c11"> is implemented</span><span> as</span><span class="c11"> a Pyretic module. You can build multiple network policies and compose them (sequential or parallel) together to express an overall network policy for the target network. For each network policy, you can have multiple states.</span>

<span></span>

<span>A Kinetic control program permits programmer-defined events to dynamically change forwarding behavior for an arbitrary set of flows. Such events can range from topology changes (generated by the Pyretic runtime) to security incidents (generated by an intrusion detection system). The programmer specifies an FSM description that contains set of states, each of which maps to some network behavior that are encoded using Pyretic’s policy language; and a set of transitions between those states, each of which may be triggered by events that the operator defines.</span>

<span class="c11"></span>

<span class="c11">For more details on</span> <span>Kinetic</span><span class="c11">, see</span> <span class="c2 c12">[http://kinetic.noise.gatech.edu](http://www.google.com/url?q=http%3A%2F%2Fkinetic.noise.gatech.edu&sa=D&sntz=1&usg=AFQjCNEfzj0sK9xQ4fCoym6CDb2b8u2Jbg)</span><span class="c11">.         </span>

<span class="c11"></span>

<span class="c11">We will be using the</span> <span>Kinetic</span><span class="c11"> controller, so make sure that the default, POX or Pyretic controller is not running in the background. Also, confirm that the port ‘6633’ used to communicate with OpenFlow switches by the runtime is not bounded:</span>

<span class="c11"></span>

```shell
$ sudo fuser -k 6633/tcp
```

<span class="c20 c4"></span>

<span class="c11">This will kill any existing TCP connection, using this port.</span>

<span class="c11"></span>

<span class="c11">You should also run</span> <span class="c20 c4">sudo mn -c</span><span class="c11"> and restart Mininet to make sure that everything is clean.From you Mininet console:</span>

<span class="c11"></span>

```shell
mininet> exit
```

```shell
$ sudo mn -c
```

## <a name="h.1fob9te"></a><span class="c13 c2 c3">Installing</span> <span class="c2">Kinetic</span><span class="c13 c2 c3"> on</span> <span class="c2">Y</span><span class="c13 c2 c3">our VM</span>

<span class="c11">Make sure that you have Pyretic and Pyretic installed in your VM. We recommend using the VM</span><span> </span><span class="c11">we have provided on the course website. It comes pre-installed with Mininet, P</span><span>ox,</span><span class="c11"> and Pyretic.</span>

<span class="c11"></span>

<span class="c11">In the VM, go to</span> <span class="c20 c4">"/home/mininet/pyretic/"</span><span class="c11">.</span>

<span class="c11"></span>

```
$ cd ~/pyretic
```

<span class="c20 c4"></span>

<span class="c3 c50">Make sure you have the latest Kinetic branch.</span>

<span></span>

```shell
$ git pull
$ git checkout kinetic
```

<span class="c4"></span>

<span class="c11">Check if</span> <span class="c20 c4">"~/pyretic/pyretic/kinetic"</span><span class="c11"> directory exists.</span>

<span class="c11"></span>

```shell
$ ls ~/pyretic/pyretic/kinetic
```

<span class="c20 c4"></span>

<span class="c11">Now run</span> <span>Kinetic</span><span class="c11"> module for testing.</span>

<span></span>

<span>Before running any kinetic application, we must issue this</span>

```shell
$ export KINETICPATH=$HOME/pyretic/pyretic/kinetic
```

<span></span>

<span>or add the following line in `~/.bashrc` to make it permanent.</span>

```export KINETICPATH=$HOME/pyretic/pyretic/kinetic```

<span></span>

<span></span>

<span class="c11">Move back to directory</span> <span class="c20 c4">"~/pyretic"</span><span class="c11"> and run:</span>

<span class="c11"></span>

```shell
$ python pyretic.py pyretic.kinetic.apps.ids
```

<span class="c4"></span>

<span class="c11">Check if th</span><span>is</span><span class="c11"> command produces any errors. It should start a controller and not output any error messages.</span>

<span class="c11"></span>

## <a name="h.3znysh7"></a><span class="c13 c2 c3">A</span> <span class="c2">S</span><span class="c13 c2 c3">imple</span> <span class="c2">Kinetic</span><span class="c13 c2 c3"> </span><span class="c2">E</span><span class="c13 c2 c3">xample</span>

<span class="c13 c2 c3"></span>

<span class="c11">In this simple example, you’ll fire up an authentication policy module, which drops traffic from any host that is not authenticated.</span>

<span class="c11"></span>

<span class="c11">First, fire up mininet with the following topology:</span>

<span class="c11"></span>

```shell
$ sudo mn --controller=remote --topo=single,3 --mac --arp
```

<span class="c20 c4"></span>

<span class="c11">This will create a network topology as shown in figure 1.</span>

<span class="c11"></span>

<span class="c11">Now, in a separate shell start the</span> <span>Kinetic</span><span class="c11"> “simple” application using the Pyretic runtime:</span>

<span class="c11"></span>

```shell
$ pyretic.py pyretic.kinetic.apps.ids
```

<span class="c20 c4"></span>

<span class="c11">In mininet, send a ping to host</span> <span class="c20 c4">h2</span><span class="c11"> (with IP address 10.0.0.2) from host</span> <span class="c20 c4">h1</span><span class="c11">:</span>

<span class="c11"></span>

```shell
mininet> h1 ping -c3 h2
```

<span class="c20 c4"></span>

<span class="c11">You should see that host</span> <span class="c20 c4">h1</span><span class="c11"> </span><span>can</span> <span class="c11">reach host</span> <span class="c20 c4">h2</span><span class="c11">. This is because the traffic coming from these hosts is not</span> <span>infected, yet</span><span class="c11">.</span>

<span class="c11"></span>

<span class="c11">In a separate shell use the JSON client included with Kinetic to send JSON events to the</span> <span>Kinetic</span><span class="c11"> </span><span>c</span><span class="c11">ontroller to</span> <span>indicate</span><span class="c11"> th</span><span>at</span><span class="c11"> </span><span>host h1 is infected</span><span class="c11">:</span>

<span class="c11"></span>

```shell
$ cd ~/pyretic/pyretic/kinetic
$ python json_sender.py -n infected -l True --flow="{srcip=10.0.0.1}" -a 127.0.0.1 -p 50001
```

<span class="c4"></span>

<span>This command sends a JSON message to the Kinetic controller indicating that host</span> <span class="c4">h1</span><span> is infected.  The Kinetic control program you are running has a Finite State Machine (FSM) policy that says when a host corresponding to the flow space with a specific source IP address transitions to an infected state, the policy for that part of flow space should transition from “passthrough” to “drop”.</span>

<span></span>

<span>Sending an event that indicates that the host is no longer infected should cause</span> <span class="c4">h1</span><span> to no longer be blocked:</span>

<span class="c4"></span>

```shell
$ python json_sender.py -n infected -l False --flow="{srcip=10.0.0.1}" -a 127.0.0.1 -p 50001
```

<span class="c4"></span>

<span>Now,</span><span class="c11"> the ping will pass and you should see replies coming back from host</span> <span class="c20 c4">h2</span><span class="c11">.</span>

<span class="c11"></span>

<span>Let’s have a closer</span><span class="c11"> look at the code:</span>

```python
from pyretic.lib.corelib import *
from pyretic.lib.std import *
from pyretic.kinetic.fsm_policy import *
from pyretic.kinetic.drivers.json_event import JSONEvent
from pyretic.kinetic.smv.model_checker import *
class ids(DynamicPolicy):
    def __init__(self):
       ### DEFINE THE LPEC FUNCTION
        def lpec(f):
            return match(srcip=f['srcip'])
        ## SET UP TRANSITION FUNCTIONS
        @transition
        def infected(self):
            self.case(occurred(self.event),self.event)
        @transition
        def policy(self):
            self.case(is_true(V(‘infected’)),C(drop))
            self.default(C(identity))
        ### SET UP THE FSM DESCRIPTION
        self.fsm_def = FSMDef(
            infected=FSMVar(type=BoolType(),
                            init=False,
                            trans=infected),
            policy=FSMVar(type=Type(Policy,{drop,identity}),
                          init=identity,
                          trans=policy))
        ### SET UP POLICY AND EVENT STREAMS
        fsm_pol = FSMPolicy(lpec,self.fsm_def)
        json_event = JSONEvent()
        json_event.register_callback(fsm_pol.event_handler)
        super(ids,self).__init__(fsm_pol)
def main():
    pol = auth()
    return pol >> flood()
```
<span class="c11 c3">Table 1: Simple</span> <span class="c3">Kinetic</span><span class="c11 c3"> IDS application.</span>

<span>Notice how short and concise the code is.  We will now walk through the application to help explain how to write a Kinetic control program.</span>

### <a name="h.tyjcwt"></a><span class="c2">Writing Kinetic Control Programs</span>

<span>A Kinetic program has several parts:</span>

*   <span class="c3">The LPEC function.</span><span>  An LPEC refers to the maximal set of located packets (i.e., flowspace) that one independent FSM instance will handle. A programmer can represent a LPEC using any Pyretic filter. For example, the LPEC containing all packets whose source IP address is 10.0.0.1 can be expressed simply as</span> <span class="c4">match(srcip=IPAddr(’10.0.0.1’))</span><span>.</span>
*   <span class="c3">Transition functions.</span> <span>A transition function encodes logic that indicates the new value a variable should take when a particular event arrives at the controller.  </span><span>For example, the infected transition function encodes a single case</span><span>: when an infected event occurs, the new value taken by the infected variable is the value of that event. Changes to any given FSM state variable (i.e., transitions) are triggered for one of two reasons:</span>

*   <span>exogenous, the arrival of an external event upon which this variable’s value depends; and</span>
*   <span>endogenous, the change of another variable upon which this variable’s value depends.</span>

*   <span class="c3">FSM definition.</span> <span>The FSM associates the transition functions that we define with the appropriate state variables.  The FSM definition consists of a set of state variable definitions. Each variable definition simply specifies the variable’s type (i.e., set of allowable values), initial value, and associated transition functions.  The</span> <span class="c4">infected</span><span> variable is a boolean whose initial value is False (representing the assumption that hosts are initially uninfected), and transitions based on the infected function defined previously. Likewise, the</span> <span class="c4">policy</span><span> variable can take the values drop or identity, initially starts off in the identity state, and transitions based on the policy function defined previously.</span>
*   <span class="c3">Policy and event streams.  </span><span>The</span> <span class="c4">FSMPolicy</span><span> that Kinetic provides automatically directs each incoming event to the appropriate LPEC FSM, where it will be handled by the exogenous transition function specified in the FSM description (e.g.,</span> <span class="c4">fsm_desc</span><span> above).</span>

<span class="c2 c40 c3 c41"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 354.00px; height: 177.00px;">![](https://d396qusza40orc.cloudfront.net/sdn/srcs/Kinetic%20Assignment/image01.png)</span>

<span class="c41 c2 c40 c3"></span>

## <a name="h.3dy6vkm"></a><span class="c13 c2 c3">Example with Sequential Composition</span>

<span class="c13 c2 c3"></span>

<span class="c11">A more complicated example shows the power of having multiple FSMs to process events and then using sequential composition to apply policies to the traffic.</span>

<span class="c11"></span>

<span class="c11">Start the Mininet Topology, as in the previous example:</span>

<span class="c11"></span>
```shell
$ sudo mn --controller=remote --topo=single,3 --mac --arp
```

<span class="c20 c4"></span>

<span class="c11">Run the</span> <span>Kinetic</span><span class="c11"> “main” application:</span>

<span class="c11"></span>

```shell
$ pyretic.py pyretic.kinetic.examples.auth_ml_ids
```

<span class="c20 c4"></span>

<span class="c11">In mininet, send a ping to host</span> <span class="c20 c4">h2</span><span class="c11"> (with IP address 10.0.0.2) from host</span> <span class="c20 c4">h1</span><span class="c11">:</span>

<span class="c11"></span>

```shell
mininet> h1 ping -c3 h2
```

<span class="c20 c4"></span>

<span class="c11">You should see that host</span> <span class="c20 c4">h1</span><span class="c11"> is not able to reach host</span> <span class="c20 c4">h2</span><span class="c11">. This is because the traffic coming from these hosts is not yet authenticated.</span>

<span class="c11"></span>

<span class="c11">Use JSON client to send JSON events to the</span> <span>Kinetic</span><span class="c11"> </span><span>c</span><span class="c11">ontroller, to authenticate the two hosts:</span>

<span class="c11"></span>

```shell
$ cd ~/pyretic/pyretic/kinetic
$ python json_sender.py -n authenticated -l True --flow="{srcip=10.0.0.1}" -a 127.0.0.1 -p 50001
$ python json_sender.py -n authenticated -l True --flow="{srcip=10.0.0.2}" -a 127.0.0.1 -p 50001
```


<span class="c20 c4"></span>

<span class="c11">You will see that sending a ping this time to host</span> <span class="c20 c4">h2</span><span class="c11"> from</span> <span class="c20 c4">h1</span><span class="c11"> </span><span>now</span><span class="c11"> </span><span>succeeds</span><span class="c11">.</span>

<span></span>

<span>Similarly, you can block traffic as before, with an IDS event:</span>

<span></span>

```shell
$ python json_sender.py -n infected -l True --flow="{srcip=10.0.0.1}" -a 127.0.0.1 -p 50002
```

<span></span>

<span class="c11">This is because the policy on the packets is a sequential composition of the authentication policy and the IDS policy, no packets go through until</span> <span class="c11 c27">both</span><span class="c11"> of these policies have a passthrough policy.</span>

<span></span>

<span class="c3">`Note`:</span> <span>The "infected" event should be sent to port 50002\. Port 50001 is solely used by the auth application in this case. There is one TCP port number assigned per FSM, which is incremented by one as new FSMs that take external events are instantiated.  (Yes, this is not the most intuitive behavior, and we are working to address this in future versions!)</span>

<span></span>

<span>Resetting the infected variable to false will again allow traffic to pass from</span> <span class="c4">h1</span><span> to other hosts on the network</span><span class="c11">.</span>

<span class="c11"></span>

<span class="c11">Here’s the code for the “main” application:</span>

```python

from pyretic.kinetic.apps.ids import ids
from pyretic.kinetic.apps.mac_learner import mac_learner
from pyretic.kinetic.apps.auth import auth
def main():
    return auth() >> mac_learner() >> ids()

```

<span class="c11 c3">Table 2:</span> <span class="c3">Kinetic</span><span class="c11 c3"> application with</span> <span class="c3">s</span><span class="c11 c3">equential composition.</span>

<span class="c3"></span>

<span>Composing event-driven FSM policies is as easy as it was in Pyretic.  Simply use Pyretic’s sequential composition policies to compose policies that you have already specified.  In this particular example, we compose the authentication policy above with a MAC learning switch, followed by the IDS policy.  As it turns out, you can also write a MAC learning switch in Kinetic.  The policy above is actually a Kinetic policy that changes states in conjunction with topology events.  You can see that policy</span> <span class="c2 c12">[here](https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Ffrenetic-lang%2Fpyretic%2Fblob%2Fkinetic%2Fpyretic%2Fkinetic%2Fapps%2Fmac_learner.py&sa=D&sntz=1&usg=AFQjCNEC-kXh24lUo-7yT1C2FuQPVIaSxQ)</span><span>.</span>

<span class="c2 c40 c3 c48"></span>

#### <span class="c2 c40 c3 c48">Model Checking and Verification with Kinetic</span>

<span>You’ll also note that the example IDS application has some logical assertions that the Kinetic controller attempts to verify using a model checker called</span> <span class="c2 c12">[NuSMV](http://www.google.com/url?q=http%3A%2F%2Fnusmv.fbk.eu%2F&sa=D&sntz=1&usg=AFQjCNEnZCH9nFJvKcmtwHd72EAJOA8e5A)</span><span>.  There are three statements that are listed in the example code.</span>

<span></span>

<span>The first statement says that an infected event for some LPEC should result in the next policy being “drop” (i.e.,</span> <span class="c4">policy_1</span><span>).  The second statement says that if an infected variable transitions to false, the next policy should be “passthrough” (i.e.,</span> <span class="c4">policy_2</span><span>).  The final statement says that the default policy should be “allow” until the infected variable becomes true.</span>

```python
'If infected event is true, next policy state is 'drop''
mc.add_spec("SPEC AG (infected -> AX policy=policy_1)")
'If infected event is false, next policy state is 'allow''
mc.add_spec("SPEC AG (!infected -> AX policy=policy_2)")
'Policy state is 'allow' until infected is true.'
mc.add_spec("SPEC A [ policy=policy_2 U infected ]")
```

<span>Below is the set of NuSMV logical operators that can help you understand the modifiers A, G, X, and U above.  The logic is a little tricky and takes some getting the hang of.  The trick with reasoning about CTL is to realize that all computation paths are represented as a tree from the current state.  Any transition will result in transitioning down the tree to another node.  A “path” in CTL is not a network path, but rather an execution path in this tree.  So, in the table below, “all paths from the current state” basically means “for all nodes on paths in the tree rooted at the current state”.</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.00px; height: 143.87px;">![](https://d396qusza40orc.cloudfront.net/sdn/srcs/Kinetic%20Assignment/image00.png)</span><span> </span>

<span></span>

<span>So, reading for example the first SMV specification literally, you might say “for all paths globally from the current state, an infected transition should always result in the policy becoming</span> <span class="c4">policy_2</span><span> as the next state from the current state”.  You should practice reading and writing these logical statements.  This</span> <span class="c2 c12">[additional background on computation tree logic (CTL)](http://www.google.com/url?q=http%3A%2F%2Fwww.cs.cmu.edu%2F~emc%2F15-820A%2Freading%2Flecture_0.pdf&sa=D&sntz=1&usg=AFQjCNFkXXARtktGGkH_2KKEcI7ZhJRIPw)</span><span> may also be useful.</span>

<span></span>

<span>The other inconvenience is that you first have to write your policy to determine that</span> <span class="c4">policy_1</span><span> corresponds to drop and</span> <span class="c4">policy_2</span><span> corresponds to allow.</span>

## <a name="h.r6bzhsczylh8"></a><span class="c13 c2 c3">Assignment</span>

<span>The assignment has two parts.  You’ll first use Kinetic to make small modifications to the IDS module (and write some rules to verify that it is correct).  You’ll then re-implement the same application that you implemented in Kinetic in either Pyretic or Pox. To start this exercise, do a git pull and check the directory `/vagrant/assignments/kinetic-gardenwall/` 

<span>You will use the following files:</span>

<span></span>

*   <span class="c4">`kinetic_gardenwall.py`:</span> <span>Skeleton code for the gardenwall application (Kinetic).</span>
*   <span class="c4">`pox_gardenwall.py`:</span> <span>Skeleton code for the gardenwall application (Pox).</span>
*   <span class="c4">`pyretic_gardenwall.py`:</span> <span>Skeleton code for the gardenwall application (Pyretic).</span>
*   <span class="c4">`submit.py`</span><span>: used to submit your code and output to the coursera servers for grading.</span>
*   <span class="c4">`rewrite.py`</span><span>: A helper file for Pox gardenwall application (Make sure that you copy this file to the directory ~/pox/pox/misc/)</span>

<span></span>
All parts of this assignment use the topology below. 
<span></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 543.00px; height: 348.03px;">![](https://d396qusza40orc.cloudfront.net/sdn/srcs/Kinetic%20Assignment/image03.png)</span>

<span>Figure 2: Topology for the network under test for this assignment.</span>

<span class="c35 c2 c3"></span>

### <span class="c35 c2 c3">Part 1: Host Gardenwall</span>

<span class="c35 c2 c3"></span>

<span>In this part of the assignment, you will augment the IDS module that we have been studying so that some hosts might be classified as “exempt” from blocking, even if they transition to an infected state.  In our simple example, the hosts that are in an “exempt” but “infected” state will be redirected to different server whenever they attempt to access any destination.  An application of this example might be in an enterprise network setting, where infected hosts belonging to guests are simply cut off of the network entirely, but hosts belonging to employees, students, etc. are instead redirected to a “garden wall”.</span>

<span></span>

<span>Your example application should have the following modifications:</span>

*   <span>Modify the finite state machine to have an “exempt” state, in addition to the “infected” state.  (So, a host can either be infected or not, and exempt or not.)</span>
*   <span>Create a new policy using Pyretic, gardenwall, which modifies traffic in the example topology to redirect all traffic from an infected but exempt host to</span> <span class="c27">any</span><span> destination to host 10.0.0.3 (let’s assume that 10.0.0.3 is a host where the gardenwall server would be located).</span>
*   <span>Write and check your CTL logic to verify that your host machine satisfies the following table of policies:</span>

<span></span>

[](#)[](#)

<table cellpadding="0" cellspacing="0" class="c29">

<tbody>

<tr class="c19">

<td class="c39">

<span class="c5"></span>

</td>

<td class="c39">

<span class="c11 c22 c3">Infected</span>

</td>

<td class="c39">

<span class="c11 c22 c3">Not Infected</span>

</td>

</tr>

<tr class="c19">

<td class="c39">

<span class="c11 c22 c3">Exempt</span>

</td>

<td class="c39">

<span class="c5">“gardenwall”:  
Redirect to 10.0.0.3  
(rewrite dst IP)</span>

</td>

<td class="c39">

<span class="c5">“identity” (allow)</span>

</td>

</tr>

<tr class="c19">

<td class="c39">

<span class="c11 c22 c3">Not Exempt</span>

</td>

<td class="c39">

<span class="c5">“drop”:</span>

<span class="c5">Drop</span>

</td>

<td class="c39">

<span class="c5">“identity” (allow)</span>

</td>

</tr>

</tbody>

</table>

<span></span>

<span></span>

<span>The following function will be helpful:</span>

<span> </span>

*   <span>rewriteDstIPAndMAC(): This is to change the dstip addres to a specific IP address *</span><span class="c3">whatever the dstip is</span><span>*  (more exactly, if the dstip matches any of the given client IPs).</span>

<span> </span>

<span></span>

<span></span>

#### <span class="c35 c2 c3">Testing Your Code</span>

<span class="c35 c2 c3"></span>

<span>Copy the gardenwall file to appropriate directory:</span>

<span></span>

```shell
$ mv kinetic_gardenwall.py ~/pyretic/pyretic/kinetic/examples/gardenwall.py
```

<span></span>

<span>Run your Kinetic controller application:</span>

<span></span>

```shell
$ cd ~/pyretic
$ pyretic.py pyretic.kinetic.examples.gardenwall
```


<span class="c3 c37"></span>

<span>Start the mininet setup in a new console.</span>

<span></span>

```shell
$ sudo mn --controller=remote --topo=single,3 --mac --arp
```

<span></span>

<span>Start a ping from h1 to h2</span>
```
mininet> h1 ping h2
64 bytes from 10.0.0.2: icmp_req=57 ttl=64 time=44.6 ms
64 bytes from 10.0.0.2: icmp_req=58 ttl=64 time=73.7 ms
64 bytes from 10.0.0.2: icmp_req=59 ttl=64 time=64.2 ms
```


<span>Now send an event to block the traffic "h1 ping h2"  (in "~/pyretic/pyretic/kinetic" directory)</span>

```python
$ python json_sender.py -n infected -l True --flow="{srcip=10.0.0.1}" -a 127.0.0.1 -p 50001
```

<span>You’ll now observe that h1 is not able to reach h2.</span>

<span></span>

<span>Next you’ll make h1's flow exempted from the IDS infection event. h1's traffic should be forwarded to 10.0.0.3 after issuing this command:</span>

```shell
$ python json_sender.py -n exempt -l True --flow="{srcip=10.0.0.1}" -a 127.0.0.1 -p 50001
```
You’ll observe that h1 is now receiving response from host h3.
```
64 bytes from 10.0.0.3: icmp_req=89 ttl=64 time=80.8 ms
64 bytes from 10.0.0.3: icmp_req=90 ttl=64 time=66.2 ms
64 bytes from 10.0.0.3: icmp_req=91 ttl=64 time=52.0 ms
64 bytes from 10.0.0.3: icmp_req=92 ttl=64 time=78.9 ms
```


After you send the events to allow th traffic again:
``` shell
$ python json_sender.py -n infected -l False --flow="{srcip=10.0.0.1}" -a 127.0.0.1 -p 50001
```


You’ll observe that h1 is now receiving response from host h2 itself.

```
64 bytes from 10.0.0.2: icmp_req=57 ttl=64 time=44.6 ms
64 bytes from 10.0.0.2: icmp_req=58 ttl=64 time=73.7 ms
64 bytes from 10.0.0.2: icmp_req=59 ttl=64 time=64.2 ms
```

### Part 2 (and 3): Reimplementation of Gardenwall in Pox or Pyretic
(or both for extra credit!)

<span></span>

<span>In the second part of this assignment, you will compare your implementation of a gardenwall application to a similar implementation in Pox, Pyretic, or both.  We have solved Part 1 of this assignment using all three controller languages and have come up with some interesting insights of our own, but we are interested in your experiences programming the same application in multiple control frameworks/languages.</span>

<span></span>

<span>Your task for the second part of this assignment is simply to re-implement Part 1 using the controller of your choice (either Pox or Pyretic).  </span><span class="c27">You can also choose to re-implement the gardenwall application in both Pox and Pyretic for extra credit.</span><span>  In other words, choosing one of either Pox or Pyretic to re-implement the gardenwall is mandatory.  You may choose to re-implement the gardenwall in both Pox and Pyretic.  </span>

<span></span>

<span class="c3">The only difference with the application above is that your event processor should process an event based on source MAC address, rather than IP address.</span>

<span></span>

<span class="c3">Extra-credit grading:</span><span> The grading for the extra credit is as follows: If you complete the extra credit, we will drop your lowest programming assignment score and your lowest quiz score.  (This policy is subject to our ability to express this formula in Coursera’s graders; we think we can implement this using the Coursera grader, but if we cannot do this exactly, we will do something similarly fair.)</span>

<span></span>

#### <span class="c35 c2 c3">Testing Your Code</span>

<span></span>

<span>Make sure that you work on the</span> <span class="c4">pox_g</span><span class="c4">ardenwall</span><span class="c4">.py and pyretic_</span><span class="c4">gardenwall</span><span class="c4">.py</span> <span>files provided with this assignment. Copy these files to appropriate directories:</span>

<span></span>

```shell
$ mv pox_gardenwall.py ~/pox/pox/misc/gardenwall.py
$ mv pyretic_gardenwall.py ~/pyretic/pyretic/examples/gardenwall.py
```

<span></span>

<span>1a. Run your Pox controller application (Part 2):</span>

<span></span>

```shell
$ cd ~/pox
$ pox.py pox.misc.gardenwall forwarding.l2_learning
```

<span></span>

<span class="c3">OR</span>

<span></span>

<span>1b. Run your Pyretic controller application (Part 3):</span>

<span></span>

```shell
$ cd ~/pox
$ pox.py pox.misc.gardenwall forwarding.l2_learning
```


<span class="c4"></span>

<span>2\. Start the mininet setup in a new console.</span>

<span></span>

```shell
$ sudo mn --controller=remote --topo=single,3 --mac --arp
```

<span></span>

<span>For either of these controllers, s</span><span>tart a ping from h1 to h2</span>

```shell
mininet> h1 ping h2
```

<span></span>

<span>Send Event to block traffic "h1 ping h2" (in "~/pyretic/pyretic/kinetic" directory)</span>

```shell
$ python json_sender.py -n infected -l True --flow="{srcmac=00:00:00:00:00:01}" -a 127.0.0.1 -p 50001
```

<span></span>

<span>Make h1's flow not be affected by IDS infection event, h1's traffic should be forwarded to 10.0.0.3 after issuing this command:</span>

```shell
$ python json_sender.py -n exempt -l True --flow="{srcmac=00:00:00:00:00:01}" -a 127.0.0.1 -p 50001
```

<span class="c4"></span>

<span>Events to now allow traffic again:</span>

```shell
$ python json_sender.py -n exempt -l True --flow="{srcmac=00:00:00:00:00:01}" -a 127.0.0.1 -p 50001
```

<span class="c4"></span>

### <span class="c35 c2 c3">Part 4: Survey about Pox, Pyretic, and Kinetic</span>

<span></span>

<span>We are interested in gathering your experiences about programming the same application in Pox, Pyretic, and Kinetic.  Thus, the last part of this assignment is to</span> <span class="c2 c3 c12">[complete the survey](https://class.coursera.org/sdn1-001/quiz/start?quiz_id=177)</span><span> asking you to compare your experiences programming in each of these languages.  </span>

<span></span>

<span>The survey is not graded (in other words, there are no right answers!), but you must complete it to receive credit for this assignment.</span>

<span class="c4"></span>

<span class="c4"></span>

## <a name="h.3rdcrjn"></a><span class="c51 c2 c40 c3 c32">Submitting</span> <span class="c2 c32">Y</span><span class="c2 c40 c3 c32 c51">our Code</span>

<span class="c2 c40"></span>

<span></span>

<span class="c11">Run</span> <span>the</span><span class="c11"> controller application in one console:</span>

<span></span>

<span>Part 1:</span>

<span class="c11"></span>

```shell
$ cd ~/pyretic
$ pyretic.py pyretic.kinetic.examples.gardenwall
```

<span class="c4"></span>

<span>Part 2:</span>

<span></span>

```shell
$ cd ~/pox
$ pox.py pox.misc.gardenwall forwarding.l2_learning
```

<span class="c4"></span>

<span>Part 3:</span>

<span></span>

```shell
$ cd ~/pyretic
$ pyretic.py pyretic.examples.gardenwall
```

<span class="c20 c4"></span>

<span>`Note`: You should not try to run all the controllers simultaneously. Start the controller for the part you want to submit, run the submit.py script as explained below. Stop the running controller before you try to submit the next part.</span><span class="c4"> </span>


<span>In another console</span><span class="c11">, run the submit.py script, under the</span> <span class="c20 c4">~/pyretic/pyretic/</span><span class="c4">kinetic</span><span class="c20 c4"> </span><span class="c11">directory:</span>

<span class="c11"></span>

```shell
$ cd ~/pyretic/pyretic/kinetic
$ sudo python submit.py
```

<span class="c20 c4"></span>

<span></span>

<span>Use the appropriate part numbers when prompted.</span> <span class="c11">Your VM should have internet access by default, but still verify that it has</span> <span>I</span><span class="c11">nternet connectivity (i.e., eth0 set up as NAT). Otherwise</span> <span class="c20 c4">`submit.py`</span><span class="c11"> will not be able to post your code and output to our</span> <span>C</span><span class="c11">oursera servers.</span>

<span class="c11"></span>

<span class="c11">The submission script will ask for your login and password. This password is not the general account password, but an assignment-specific password that is uniquely generated for each student. You can get this from the assignments listing page.</span>

<span class="c11"></span>

<span class="c11">Once finished, it will prompt the results on the terminal (either passed or failed).</span>

<span></span>

<span class="c11">Note, if during the execution</span> <span class="c20 c4">submit.py</span> <span class="c11">script crashes for some reason or you terminate it using `CTRL+C`, make sure to clean mininet environment using:</span>

```shell
$ sudo mn -c
```

<span class="c20 c4"></span>

<span class="c11">Also, if it still complains about the controller running. Execute the following command to kill it:</span>

<span class="c11"></span>

```shell
$ sudo fuser -k 6633/tcp
```

<span class="c20 c4"></span>

### <span class="c2 c40 c3 c47">Appendix 1: Writing a Kinetic Application</span>

<span class="c2 c40 c3 c47"></span>

*  <span class="c3">Define class for the application, subclassed from DynamicPolicy</span>
*  <span class="c3">Define LPEC</span>: 
  	* <span>Define the packet space fields that will used to categorize packets to have equivalent policies applied. Unspecified fields will be wildcarded.  In this assignment, you have to only define one type of LPEC (based on source IP address of the sender); you might imagine defining LPECs based on other parts of flow space, however.</span>

*  Set up transition functions
	*  <span>Use “@transition” decorator		
    	* <span>This decorator ensures the transiotion is fed into the NuSMV input automatic translator</span>

	* <span>There are two types of transition functions to define:</span>

		* <span>For events</span>
		* <span>For policies</span>

* <span class="c3">Set up the FSM description</span>

	* <span>Define variable’s type, initial value, and transition function</span>
	* <span>Both event and policy are variables</span>
		* <span class="c3">type</span><span>: Type of this variable (e.g., boolean, integer, Pyretic policy)</span>
		* <span class="c3">init</span><span>: Initial value for this variable</span>
		* <span class="c3">trans</span><span>: transition function for this variable. Whenever an event arrives, the specified transition function is called.</span>

*  <span class="c3">Set up policy and event streams</span>

	* <span>Create FSMPolicy.</span>
	* <span>Register for events (e.g,. JSON events), so that it’s called every time an event arrives.</span>

	* <span class="c2 c3">`Note`:</span><span class="c3"> </span><span>Normally, this part pretty much remains the same for any application, so no need to add/modify unless your application listens to non-JSON events.</span>

* <span class="c3">Define “main” method</span>

	*  <span>Add methods to get ready for NuSMV model checker, if you want verification.</span>

		*   <span>smv_str = fsm_def_to_smv_model(pol.fsm_def)</span>
		*   <span>mc = ModelChecker(smv_str,'ids')</span>

*  <span class="c3">Add SPEC lines, which is in CTL (Computation Tree Logic) language.</span>

	*  <span>Add statements that should be verified.</span>
	*  <span>Some IDS examples:</span>

		*  <span class="c3">If infected event is true, next policy state is 'drop':</span>

			*   <span>mc.add_spec("SPEC AG (infected -> AX policy=drop)")</span>

		*  <span class="c3">Policy state is 'allow' until infected is true.</span>

			*   <span>mc.add_spec("SPEC A [ policy=allow U infected ]")</span>

*  <span class="c3">Return DynamicPolicy instance.</span>

<span></span>

### <span class="c2 c40 c3 c47">Appendix 2: Other Possibly Useful Functions</span>

<span class="c2 c40 c3 c47"></span>

<span>Some questions have come up in the past about the difference between these two functions in the Kinetic utilities, which may prove useful for the assignment:</span>

*   <span class="c4">`rewriteDstIPAndMAC_Public()`:</span><span> This is to change the dstip address to a specific IP address if the dstip matches a public IP (e.g., 10.0.0.100). This might be used in a “primary-backup” application where the src host knows that it has to send traffic to a specific public IP.</span>
*   <span class="c4">`rewriteDstIPAndMAC()`</span><span>: This is to change the dstip addres to a specific IP address *whatever the dstip is*  (more exactly, if the dstip matches any of the given client IPs). This is useful for the Gardenwall application.</span>

<span class="c2 c40 c3 c47"> </span>

<span class="c2 c40 c3 c47"></span>

<span></span>
